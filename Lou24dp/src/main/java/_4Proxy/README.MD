简介
====
代理模式就是给一个对象提供一个代理对象，
由这个代理对象控制对原对象的引用，使代理类在客户端和原对象之间起到中介的作用。
（为其他对象提供一种代理以控制对这个对象的访问）

![代理模式](http://www.jasongj.com/img/designpattern/proxydecorator/ProxyPattern.png)

组成角色
=======
- 抽象目标类；（定义代理类和具体目标类的公共对外方法）
- 具体目标类；（真正实现业务逻辑的类）
- 代理类；（用来代理和封装具体目标类）
- 客户端Main；（通过代理类封装实例化的具体目标类，并执行逻辑方法）

分类及区别
==========
静态代理：
通过业务逻辑的代理类来调用具体的业务逻辑。
代理者的代码有程序员或自动生成工具生成固定的代码再对其进行编译，
也就是说在我们的代码运行之前代理类的class文件已经存在。


动态代理：
通过Java的反射机制动态的生成代理者对象。在code阶段无法知晓具体的代理类，而是在执行阶段决定的。

在动态代理上所做的所有调用都会被重定向到单一的`调用处理器`上（InvocationHandler），
代理类的内部逻辑由`InvocationHandler`的实现者决定，
它的工作是揭示调用的类型并确定相应的对策。
动态代理可以将所有调用重定向到`调用处理器`，因此通常会向调用处理器的构造器传递一个“实际”的对象引用，
从而使得调用处理器在执行其中介任务时，可以将请求转发。

参考资料
=======
- 《Thinking in java 4th》 14.7节
- 《易学设计模式》11章
- 《Android源码设计模式》 18章
- [代理模式原理及实例讲解](https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/)